(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{363:function(e,a,s){"use strict";s.r(a);var t=s(39),n=Object(t.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"database-indexing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#database-indexing"}},[e._v("#")]),e._v(" Database indexing")]),e._v(" "),s("p",[e._v("2021.08.30")]),e._v(" "),s("h2",{attrs:{id:"heap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#heap"}},[e._v("#")]),e._v(" Heap")]),e._v(" "),s("p",[e._v("In database, heap is an unordered table. It is just pages stored in disk.")]),e._v(" "),s("p",[e._v("If you insert a row into a heap, you are not guaranteed with any order of the rows (pages).")]),e._v(" "),s("p",[e._v("So, obviously searching for a specific row will not be efficient.")]),e._v(" "),s("p",[e._v("Therefore, comes indexes!")]),e._v(" "),s("h2",{attrs:{id:"clustered-index"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#clustered-index"}},[e._v("#")]),e._v(" Clustered index")]),e._v(" "),s("p",[e._v("Index is a separate structure from table, which only contains information about the ordering of the table.")]),e._v(" "),s("p",[e._v("The purpose of index is to optimize the queries and therefore, search efficiently.")]),e._v(" "),s("p",[e._v("Normally, the index is implemented as B-trees or LSM trees and primary key is the default column for indexes in many databases. (You can make other indexes with other columns).")]),e._v(" "),s("p",[e._v("Clustered index is also very good for range queries, since nearby/similar keys will be clustered, reducing heap acess and increasing cache hit rate.")]),e._v(" "),s("h2",{attrs:{id:"query-plans-and-optimization"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#query-plans-and-optimization"}},[e._v("#")]),e._v(" Query plans and optimization")]),e._v(" "),s("ul",[s("li",[e._v('"explain" and "analyze" commands in database shows the query plan and the query execution time.')])]),e._v(" "),s("p",[e._v('If using index, performing select queries with a "where" condition on indexed columns, the database will first access the index table and then access the heap for actual data when needed. Therefore, not requiring the full scan of the table.')]),e._v(" "),s("p",[e._v('When you have an index using the "id" column,  the below query will only need to access the index table, not the heap, because the query only asked for "id" which is in the index table => query plan = "Index only scan"')]),e._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("select")]),e._v(" id "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("from")]),e._v(" table1 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("where")]),e._v(" id "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),s("p",[e._v('But, if you ask for more columns, the database will have to access the heap, since "name" column is not in the index table, only in the heap => query plan = "Index scan"')]),e._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("select")]),e._v(" id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" name "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("from")]),e._v(" table1 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("where")]),e._v(" id "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),s("p",[e._v("For freqeuently accessed columns, it seems like a good idea to make another index for that column.")]),e._v(" "),s("p",[e._v('In case of using a where condition on non-indexed columns, the database has to do a full scan unfortunately => query plan "Seq scan"')]),e._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("select")]),e._v(" id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" grade "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("from")]),e._v(" table1 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("where")]),e._v(" grade"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("55")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),s("p",[e._v("Normally bad queries")]),e._v(" "),s("ul",[s("li",[e._v("SELECT * queries :  always require heap access")]),e._v(" "),s("li",[e._v("LIKE clause : needs to do full scan despite the presence of index table")])])])}),[],!1,null,null,null);a.default=n.exports}}]);